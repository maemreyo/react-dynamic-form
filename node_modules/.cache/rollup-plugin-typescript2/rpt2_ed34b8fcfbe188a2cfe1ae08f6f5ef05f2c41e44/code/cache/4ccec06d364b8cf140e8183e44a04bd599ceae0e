{"code":"// Filepath: /src/features/validation/validationSchema.ts\nimport * as yup from 'yup';\nimport { getValidationSchema } from './ValidationSchemaRegistry';\n/**\n * Handles the 'required' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'required' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleRequired = (fieldSchema, ruleValue, validationMessages) => {\n    const requiredMessage = typeof ruleValue === 'object'\n        ? ruleValue.message\n        : validationMessages?.required || 'This field is required';\n    return fieldSchema.required(requiredMessage);\n};\n/**\n * Handles the 'minLength' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'minLength' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMinLength = (fieldSchema, ruleValue, validationMessages) => {\n    if (typeof ruleValue === 'number' ||\n        typeof ruleValue === 'string' ||\n        typeof ruleValue?.value === 'number' ||\n        typeof ruleValue?.value === 'string') {\n        const value = typeof ruleValue === 'number' || typeof ruleValue === 'string'\n            ? ruleValue\n            : ruleValue.value;\n        const message = ruleValue.message ||\n            validationMessages?.minLength?.replace('{value}', value.toString()) ||\n            `minLength should be ${value}`;\n        return fieldSchema.min(value, message);\n    }\n    return fieldSchema;\n};\n/**\n * Handles the 'maxLength' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'maxLength' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMaxLength = (fieldSchema, ruleValue, validationMessages) => {\n    if (typeof ruleValue === 'number' ||\n        typeof ruleValue === 'string' ||\n        typeof ruleValue?.value === 'number' ||\n        typeof ruleValue?.value === 'string') {\n        const value = typeof ruleValue === 'number' || typeof ruleValue === 'string'\n            ? ruleValue\n            : ruleValue.value;\n        const message = ruleValue.message ||\n            validationMessages?.maxLength?.replace('{value}', value.toString()) ||\n            `maxLength should be ${value}`;\n        return fieldSchema.max(value, message);\n    }\n    return fieldSchema;\n};\n/**\n * Handles the 'min' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'min' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMin = (fieldSchema, ruleValue, validationMessages) => {\n    if (typeof ruleValue === 'number' ||\n        typeof ruleValue === 'string' ||\n        typeof ruleValue?.value === 'number' ||\n        typeof ruleValue?.value === 'string') {\n        const value = typeof ruleValue === 'number' || typeof ruleValue === 'string'\n            ? ruleValue\n            : ruleValue.value;\n        const message = ruleValue.message ||\n            validationMessages?.min?.replace('{value}', value.toString()) ||\n            `min should be ${value}`;\n        return fieldSchema.min(value, message);\n    }\n    return fieldSchema;\n};\n/**\n * Handles the 'max' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'max' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMax = (fieldSchema, ruleValue, validationMessages) => {\n    if (typeof ruleValue === 'number' ||\n        typeof ruleValue === 'string' ||\n        typeof ruleValue?.value === 'number' ||\n        typeof ruleValue?.value === 'string') {\n        const value = typeof ruleValue === 'number' || typeof ruleValue === 'string'\n            ? ruleValue\n            : ruleValue.value;\n        const message = ruleValue.message ||\n            validationMessages?.max?.replace('{value}', value.toString()) ||\n            `max should be ${value}`;\n        return fieldSchema.max(value, message);\n    }\n    return fieldSchema;\n};\n/**\n * Handles the 'pattern' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'pattern' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handlePattern = (fieldSchema, ruleValue, validationMessages) => {\n    const regex = ruleValue instanceof RegExp ? ruleValue : new RegExp(ruleValue.value);\n    const message = ruleValue.message || validationMessages?.pattern || 'Invalid format';\n    return fieldSchema.matches(regex, { message, excludeEmptyString: true });\n};\n/**\n * Applies a custom validation function to the field schema.\n *\n * @param fieldSchema - The current field schema.\n * @param validate - The custom validation function.\n * @returns The updated field schema.\n */\nconst applyCustomValidation = (fieldSchema, validate) => {\n    return fieldSchema.test('custom-validation', 'Custom validation failed', async (value, context) => {\n        const result = await validate(value, context.parent);\n        if (typeof result === 'string') {\n            return context.createError({\n                path: context.path,\n                message: result,\n            });\n        }\n        return result !== false;\n    });\n};\n/**\n * Creates a Yup validation schema based on the provided form configuration.\n *\n * @param config - The form configuration.\n * @returns The Yup schema.\n */\nexport const createValidationSchema = (config) => {\n    const shape = {};\n    const validationHandlers = {\n        required: handleRequired,\n        minLength: (fieldSchema, ruleValue, validationMessages) => handleMinLength(fieldSchema, ruleValue, validationMessages),\n        maxLength: (fieldSchema, ruleValue, validationMessages) => handleMaxLength(fieldSchema, ruleValue, validationMessages),\n        min: (fieldSchema, ruleValue, validationMessages) => handleMin(fieldSchema, ruleValue, validationMessages),\n        max: (fieldSchema, ruleValue, validationMessages) => handleMax(fieldSchema, ruleValue, validationMessages),\n        pattern: (fieldSchema, ruleValue, validationMessages) => handlePattern(fieldSchema, ruleValue, validationMessages),\n    };\n    for (const fieldId in config) {\n        const fieldConfig = config[fieldId];\n        const { validation, type, validationMessages } = fieldConfig;\n        if (type === undefined) {\n            console.warn(`Field type is undefined for field: ${fieldId}`);\n        }\n        let fieldSchema = getValidationSchema(type) || yup.mixed();\n        if (validation) {\n            const { validate, ...otherValidations } = validation;\n            for (const rule in otherValidations) {\n                if (otherValidations.hasOwnProperty(rule)) {\n                    const ruleValue = validation[rule];\n                    const handler = validationHandlers[rule];\n                    if (handler) {\n                        fieldSchema = handler(fieldSchema, ruleValue, validationMessages);\n                    }\n                }\n            }\n            if (typeof validate === 'function') {\n                fieldSchema = applyCustomValidation(fieldSchema, validate);\n            }\n        }\n        shape[fieldId] = fieldSchema;\n    }\n    return yup.object().shape(shape);\n};\n","references":["/Users/matthewngo/Documents/dev/projects/react-dynamic-form/node_modules/yup/index.d.ts","/Users/matthewngo/Documents/dev/projects/react-dynamic-form/src/features/dynamic-form/index.ts","/Users/matthewngo/Documents/dev/projects/react-dynamic-form/src/features/validation/ValidationSchemaRegistry.ts"]}
