"use strict";
self["webpackHotUpdate_matthew_ngo_react_dynamic_form"]("src_index_ts",{

/***/ "./src/features/validation/validationSchema.ts":
/*!*****************************************************!*\
  !*** ./src/features/validation/validationSchema.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createValidationSchema: () => (/* binding */ createValidationSchema)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var yup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yup */ "./node_modules/yup/index.esm.js");
/* harmony import */ var _ValidationSchemaRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValidationSchemaRegistry */ "./src/features/validation/ValidationSchemaRegistry.ts");
// Filepath: /src/features/validation/validationSchema.ts



/**
 * Handles the 'required' validation rule.
 *
 * @param fieldSchema - The current field schema.
 * @param ruleValue - The value of the 'required' rule.
 * @param validationMessages - The validation messages.
 * @returns The updated field schema.
 */
var handleRequired = function (fieldSchema, ruleValue, validationMessages) {
    var requiredMessage = typeof ruleValue === 'object'
        ? ruleValue.message
        : (validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.required) || 'This field is required';
    return fieldSchema.required(requiredMessage);
};
/**
 * Handles the 'minLength' validation rule.
 *
 * @param fieldSchema - The current field schema.
 * @param ruleValue - The value of the 'minLength' rule.
 * @param validationMessages - The validation messages.
 * @returns The updated field schema.
 */
var handleMinLength = function (fieldSchema, ruleValue, validationMessages) {
    var _a;
    if (typeof ruleValue === 'number' ||
        typeof ruleValue === 'string' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'number' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'string') {
        var value = typeof ruleValue === 'number' || typeof ruleValue === 'string'
            ? ruleValue
            : ruleValue.value;
        var message = ruleValue.message ||
            ((_a = validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.minLength) === null || _a === void 0 ? void 0 : _a.replace('{value}', value.toString())) ||
            "minLength should be ".concat(value);
        return fieldSchema.min(value, message);
    }
    return fieldSchema;
};
/**
 * Handles the 'maxLength' validation rule.
 *
 * @param fieldSchema - The current field schema.
 * @param ruleValue - The value of the 'maxLength' rule.
 * @param validationMessages - The validation messages.
 * @returns The updated field schema.
 */
var handleMaxLength = function (fieldSchema, ruleValue, validationMessages) {
    var _a;
    if (typeof ruleValue === 'number' ||
        typeof ruleValue === 'string' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'number' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'string') {
        var value = typeof ruleValue === 'number' || typeof ruleValue === 'string'
            ? ruleValue
            : ruleValue.value;
        var message = ruleValue.message ||
            ((_a = validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.maxLength) === null || _a === void 0 ? void 0 : _a.replace('{value}', value.toString())) ||
            "maxLength should be ".concat(value);
        return fieldSchema.max(value, message);
    }
    return fieldSchema;
};
/**
 * Handles the 'min' validation rule.
 *
 * @param fieldSchema - The current field schema.
 * @param ruleValue - The value of the 'min' rule.
 * @param validationMessages - The validation messages.
 * @returns The updated field schema.
 */
var handleMin = function (fieldSchema, ruleValue, validationMessages) {
    var _a;
    if (typeof ruleValue === 'number' ||
        typeof ruleValue === 'string' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'number' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'string') {
        var value = typeof ruleValue === 'number' || typeof ruleValue === 'string'
            ? ruleValue
            : ruleValue.value;
        var message = ruleValue.message ||
            ((_a = validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.min) === null || _a === void 0 ? void 0 : _a.replace('{value}', value.toString())) ||
            "min should be ".concat(value);
        return fieldSchema.min(value, message);
    }
    return fieldSchema;
};
/**
 * Handles the 'max' validation rule.
 *
 * @param fieldSchema - The current field schema.
 * @param ruleValue - The value of the 'max' rule.
 * @param validationMessages - The validation messages.
 * @returns The updated field schema.
 */
var handleMax = function (fieldSchema, ruleValue, validationMessages) {
    var _a;
    if (typeof ruleValue === 'number' ||
        typeof ruleValue === 'string' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'number' ||
        typeof (ruleValue === null || ruleValue === void 0 ? void 0 : ruleValue.value) === 'string') {
        var value = typeof ruleValue === 'number' || typeof ruleValue === 'string'
            ? ruleValue
            : ruleValue.value;
        var message = ruleValue.message ||
            ((_a = validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.max) === null || _a === void 0 ? void 0 : _a.replace('{value}', value.toString())) ||
            "max should be ".concat(value);
        return fieldSchema.max(value, message);
    }
    return fieldSchema;
};
/**
 * Handles the 'pattern' validation rule.
 *
 * @param fieldSchema - The current field schema.
 * @param ruleValue - The value of the 'pattern' rule.
 * @param validationMessages - The validation messages.
 * @returns The updated field schema.
 */
var handlePattern = function (fieldSchema, ruleValue, validationMessages) {
    var regex = ruleValue instanceof RegExp ? ruleValue : new RegExp(ruleValue.value);
    var message = ruleValue.message || (validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.pattern) || 'Invalid format';
    return fieldSchema.matches(regex, { message: message, excludeEmptyString: true });
};
/**
 * Applies a custom validation function to the field schema.
 *
 * @param fieldSchema - The current field schema.
 * @param validate - The custom validation function.
 * @returns The updated field schema.
 */
var applyCustomValidation = function (fieldSchema, validate) {
    return fieldSchema.test('custom-validation', 'Custom validation failed', function (value, context) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(void 0, void 0, void 0, function () {
        var result;
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, validate(value, context.parent)];
                case 1:
                    result = _a.sent();
                    if (typeof result === 'string') {
                        return [2 /*return*/, context.createError({
                                path: context.path,
                                message: result,
                            })];
                    }
                    return [2 /*return*/, result !== false];
            }
        });
    }); });
};
/**
 * Creates a Yup validation schema based on the provided form configuration.
 *
 * @param config - The form configuration.
 * @param globalValidationMessages - Optional global validation messages.
 * @returns The Yup schema.
 */
var createValidationSchema = function (config, globalValidationMessages) {
    var shape = {};
    var validationHandlers = {
        required: handleRequired,
        minLength: function (fieldSchema, ruleValue, validationMessages) {
            return handleMinLength(fieldSchema, ruleValue, validationMessages);
        },
        maxLength: function (fieldSchema, ruleValue, validationMessages) {
            return handleMaxLength(fieldSchema, ruleValue, validationMessages);
        },
        min: function (fieldSchema, ruleValue, validationMessages) {
            return handleMin(fieldSchema, ruleValue, validationMessages);
        },
        max: function (fieldSchema, ruleValue, validationMessages) {
            return handleMax(fieldSchema, ruleValue, validationMessages);
        },
        pattern: function (fieldSchema, ruleValue, validationMessages) {
            return handlePattern(fieldSchema, ruleValue, validationMessages);
        },
    };
    for (var fieldId in config) {
        var fieldConfig = config[fieldId];
        var validation = fieldConfig.validation, type = fieldConfig.type, validationMessages = fieldConfig.validationMessages;
        // Merge global and field-level validation messages
        var mergedValidationMessages = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, globalValidationMessages), validationMessages);
        if (type === undefined) {
            console.warn("Field type is undefined for field: ".concat(fieldId));
        }
        var fieldSchema = (0,_ValidationSchemaRegistry__WEBPACK_IMPORTED_MODULE_1__.getValidationSchema)(type) || yup__WEBPACK_IMPORTED_MODULE_0__.mixed();
        if (validation) {
            var validate = validation.validate, otherValidations = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(validation, ["validate"]);
            for (var rule in otherValidations) {
                if (otherValidations.hasOwnProperty(rule)) {
                    var ruleValue = validation[rule];
                    var handler = validationHandlers[rule];
                    if (handler) {
                        fieldSchema = handler(fieldSchema, ruleValue, mergedValidationMessages // Use merged validation messages
                        );
                    }
                }
            }
            if (typeof validate === 'function') {
                fieldSchema = applyCustomValidation(fieldSchema, validate);
            }
        }
        shape[fieldId] = fieldSchema;
    }
    return yup__WEBPACK_IMPORTED_MODULE_0__.object().shape(shape);
};


/***/ })

});
//# sourceMappingURL=src_index_ts.b4588dba78ce3c91b950.hot-update.js.map