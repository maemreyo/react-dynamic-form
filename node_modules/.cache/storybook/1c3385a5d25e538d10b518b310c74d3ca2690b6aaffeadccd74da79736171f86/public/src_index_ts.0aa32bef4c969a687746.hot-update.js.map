{"version":3,"file":"src_index_ts.0aa32bef4c969a687746.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAGA;;;;;;;AAOA;AACA;AAKA;AAKA","sources":["webpack://@matthew.ngo/react-dynamic-form/./src/features/dynamic-form/utils/formUtils.ts"],"sourcesContent":["// src/features/dynamic-form/utils/formUtils.ts\nimport { FieldClassNameConfig, FormClassNameConfig, FormConfig } from '../types';\n\n/**\n * Flattens a nested object into a single-level object.\n *\n * @param obj - The object to flatten.\n * @param parentKey - The parent key (used for recursion).\n * @param result - The resulting flattened object.\n * @returns The flattened object.\n */\nexport const flattenObject = (\n  obj: Record<string, any>,\n  parentKey = '',\n  result: Record<string, any> = {}\n): Record<string, any> => {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = parentKey ? `${parentKey}.${key}` : key;\n      if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {\n        flattenObject(obj[key], newKey, result);\n      } else {\n        result[newKey] = obj[key];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Flattens a nested config object into a single-level object.\n *\n * @param config - The config object to flatten.\n * @param parentKey - The parent key (used for recursion).\n * @param result - The resulting flattened config object.\n * @returns The flattened config object.\n */\nexport const flattenConfig = (\n  config: FormConfig,\n  parentKey = '',\n  result: FormConfig = {}\n): FormConfig => {\n  for (const key in config) {\n    if (Object.prototype.hasOwnProperty.call(config, key)) {\n      const newKey = parentKey ? `${parentKey}.${key}` : key;\n      const fieldConfig = config[key];\n      if (fieldConfig.fields) {\n        flattenConfig(fieldConfig.fields, newKey, result);\n      } else {\n        result[newKey] = fieldConfig;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Debounces a function.\n *\n * @param func - The function to debounce.\n * @param wait - The debounce time in milliseconds.\n * @returns The debounced function.\n */\nexport const debounce = (func: Function, wait: number) => {\n  let timeout: NodeJS.Timeout | null;\n  return function (...args: any[]) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n};\n\n/**\n * Saves data to localStorage.\n *\n * @param key - The key to store the data under.\n * @param data - The data to store.\n */\nexport const saveToLocalStorage = (key: string, data: any) => {\n  localStorage.setItem(key, JSON.stringify(data));\n};\n\n/**\n * Loads data from localStorage.\n *\n * @param key - The key to load the data from.\n * @returns The loaded data, or null if no data is found.\n */\nexport const loadFromLocalStorage = (key: string): any | null => {\n  const data = localStorage.getItem(key);\n  return data ? JSON.parse(data) : null;\n};\n\n\n/**\n * Merges multiple classNameConfig objects into a single object.\n *\n * @param defaultClassNames - The default classNameConfig object.\n * @param formClassNames - The form-level classNameConfig object.\n * @param fieldClassNames - The field-level classNameConfig object.\n * @returns The merged classNameConfig object.\n */\nexport const mergeClassNames = (\n  defaultClassNames: FormClassNameConfig,\n  formClassNames?: FormClassNameConfig,\n  fieldClassNames?: FieldClassNameConfig\n): FormClassNameConfig => {\n  return {\n    ...defaultClassNames,\n    ...formClassNames,\n    ...fieldClassNames,\n  };\n};"],"names":[],"sourceRoot":""}