{"version":3,"file":"src_index_ts.603418ce3da7856ade4d.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAEA;AAQA;AACA;AAEA;;;;;;;;AAQA;AACA;AAUA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;AAAA;AAEA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAZA;AAgBA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AADA;AAMA;AAKA;AACA;AAEA","sources":["webpack://@matthew.ngo/react-dynamic-form/./src/features/dynamic-form/hooks/useFormFields.ts"],"sourcesContent":["// Filepath: /src/features/dynamic-form/hooks/useFormFields.ts\n\nimport { useMemo, useState, useEffect } from 'react';\nimport {\n  FormField,\n  FormConfig,\n  Condition,\n  FormValues,\n  ValidationMessages,\n} from '../types';\nimport { FormState, useWatch, Control } from 'react-hook-form';\nimport { shouldRenderField, getFields, flattenConfig } from '../utils';\n\n/**\n * Custom hook to generate form fields from data and config.\n *\n * @param config - The form configuration.\n * @param formState - The `react-hook-form` form state.\n * @param control - The `react-hook-form` control object.\n * @param globalValidationMessages - Optional global validation messages.\n * @returns An object containing the form fields and the fields to render.\n */\nfunction useFormFields(\n  config: FormConfig,\n  formState: FormState<FormValues>,\n  control: Control<FormValues>,\n  globalValidationMessages: ValidationMessages | undefined\n): {\n  fields: FormField[];\n  fieldsToRender: string[];\n  conditionalFieldsConfig: Condition[];\n} {\n  // @ts-expect-error\n  const [update, setUpdate] = useState(false);\n\n  \n  useEffect(() => {\n    setUpdate(prev => !prev);\n  }, [config]);\n\n  const flattenedConfig = useMemo(() => flattenConfig(config), [config]);\n\n  const conditionalFieldsConfig = useMemo(\n    () =>\n      Object.keys(config)\n        .filter(\n          fieldId =>\n            config[fieldId].conditional &&\n            typeof config[fieldId].conditional?.when === 'string'\n        )\n        .map(fieldId => ({\n          when: config[fieldId].conditional!.when,\n          operator: config[fieldId].conditional!.operator || 'is',\n          value: config[fieldId].conditional?.value,\n          comparator: config[fieldId].conditional?.comparator,\n          fields: config[fieldId].conditional!.fields || [],\n        })),\n    [config]\n  );\n\n  const watchedValues = useWatch({\n    control,\n    name: conditionalFieldsConfig.map(condition => condition.when),\n  });\n\n  const fieldsToRender = useMemo(\n    () =>\n      Object.keys(config).filter(fieldId =>\n        shouldRenderField(fieldId, conditionalFieldsConfig, watchedValues)\n      ),\n    [config, conditionalFieldsConfig, watchedValues]\n  );\n\n  const fields = useMemo(\n    () => getFields(flattenedConfig, formState, globalValidationMessages),\n    [flattenedConfig, formState, globalValidationMessages]\n  );\n\n  return { fields, fieldsToRender, conditionalFieldsConfig };\n}\n\nexport default useFormFields;\n"],"names":[],"sourceRoot":""}