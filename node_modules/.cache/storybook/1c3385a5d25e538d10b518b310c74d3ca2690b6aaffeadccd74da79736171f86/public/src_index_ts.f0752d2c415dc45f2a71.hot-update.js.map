{"version":3,"file":"src_index_ts.f0752d2c415dc45f2a71.hot-update.js","mappings":";;;;;;;;;;;;;;;;AAAA;;AAEA;AAMA;AAEA;;;;;;;AAOA;AACA;AAKA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;;AAKA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;;AAKA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;;AAKA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;;AAKA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAKA;AAEA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AAIA;;;;AAIA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAEA;;;;;;AAMA;AACA;AAIA;AAEA;AAOA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA","sources":["webpack://@matthew.ngo/react-dynamic-form/./src/features/validation/validationSchema.ts"],"sourcesContent":["// Filepath: /src/features/validation/validationSchema.ts\n\nimport * as yup from 'yup';\nimport {\n  FormConfig,\n  CustomValidator,\n  ValidationMessages,\n} from '../dynamic-form';\nimport { getValidationSchema } from './ValidationSchemaRegistry';\n\n/**\n * Handles the 'required' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'required' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleRequired = (\n  fieldSchema: yup.AnySchema,\n  ruleValue: any,\n  validationMessages: any\n) => {\n  const requiredMessage =\n    typeof ruleValue === 'object'\n      ? ruleValue.message\n      : validationMessages?.required || 'This field is required';\n  return (fieldSchema as yup.StringSchema).required(requiredMessage);\n};\n\n/**\n * Handles the 'minLength' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'minLength' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMinLength = (\n  fieldSchema: yup.StringSchema,\n  ruleValue: any,\n  validationMessages: any\n) => {\n  if (\n    typeof ruleValue === 'number' ||\n    typeof ruleValue === 'string' ||\n    typeof ruleValue?.value === 'number' ||\n    typeof ruleValue?.value === 'string'\n  ) {\n    const value =\n      typeof ruleValue === 'number' || typeof ruleValue === 'string'\n        ? ruleValue\n        : ruleValue.value;\n    const message =\n      ruleValue.message ||\n      validationMessages?.minLength?.replace('{value}', value.toString()) ||\n      `minLength should be ${value}`;\n    return fieldSchema.min(value, message);\n  }\n  return fieldSchema;\n};\n\n/**\n * Handles the 'maxLength' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'maxLength' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMaxLength = (\n  fieldSchema: yup.StringSchema,\n  ruleValue: any,\n  validationMessages: any\n) => {\n  if (\n    typeof ruleValue === 'number' ||\n    typeof ruleValue === 'string' ||\n    typeof ruleValue?.value === 'number' ||\n    typeof ruleValue?.value === 'string'\n  ) {\n    const value =\n      typeof ruleValue === 'number' || typeof ruleValue === 'string'\n        ? ruleValue\n        : ruleValue.value;\n    const message =\n      ruleValue.message ||\n      validationMessages?.maxLength?.replace('{value}', value.toString()) ||\n      `maxLength should be ${value}`;\n    return fieldSchema.max(value, message);\n  }\n  return fieldSchema;\n};\n\n/**\n * Handles the 'min' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'min' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMin = (\n  fieldSchema: yup.NumberSchema,\n  ruleValue: any,\n  validationMessages: any\n) => {\n  if (\n    typeof ruleValue === 'number' ||\n    typeof ruleValue === 'string' ||\n    typeof ruleValue?.value === 'number' ||\n    typeof ruleValue?.value === 'string'\n  ) {\n    const value =\n      typeof ruleValue === 'number' || typeof ruleValue === 'string'\n        ? ruleValue\n        : ruleValue.value;\n    const message =\n      ruleValue.message ||\n      validationMessages?.min?.replace('{value}', value.toString()) ||\n      `min should be ${value}`;\n    return fieldSchema.min(value, message);\n  }\n  return fieldSchema;\n};\n\n/**\n * Handles the 'max' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'max' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handleMax = (\n  fieldSchema: yup.NumberSchema,\n  ruleValue: any,\n  validationMessages: any\n) => {\n  if (\n    typeof ruleValue === 'number' ||\n    typeof ruleValue === 'string' ||\n    typeof ruleValue?.value === 'number' ||\n    typeof ruleValue?.value === 'string'\n  ) {\n    const value =\n      typeof ruleValue === 'number' || typeof ruleValue === 'string'\n        ? ruleValue\n        : ruleValue.value;\n    const message =\n      ruleValue.message ||\n      validationMessages?.max?.replace('{value}', value.toString()) ||\n      `max should be ${value}`;\n    return fieldSchema.max(value, message);\n  }\n  return fieldSchema;\n};\n\n/**\n * Handles the 'pattern' validation rule.\n *\n * @param fieldSchema - The current field schema.\n * @param ruleValue - The value of the 'pattern' rule.\n * @param validationMessages - The validation messages.\n * @returns The updated field schema.\n */\nconst handlePattern = (\n  fieldSchema: yup.StringSchema,\n  ruleValue: any,\n  validationMessages: any\n) => {\n  const regex =\n    ruleValue instanceof RegExp ? ruleValue : new RegExp(ruleValue.value);\n  const message =\n    ruleValue.message || validationMessages?.pattern || 'Invalid format';\n  return fieldSchema.matches(regex, { message, excludeEmptyString: true });\n};\n\n/**\n * Applies a custom validation function to the field schema.\n *\n * @param fieldSchema - The current field schema.\n * @param validate - The custom validation function.\n * @returns The updated field schema.\n */\nconst applyCustomValidation = (\n  fieldSchema: yup.AnySchema,\n  validate: CustomValidator\n) => {\n  return fieldSchema.test(\n    'custom-validation',\n    'Custom validation failed',\n    async (value, context) => {\n      const result = await validate(value, context.parent);\n      if (typeof result === 'string') {\n        return context.createError({\n          path: context.path,\n          message: result,\n        });\n      }\n      return result !== false;\n    }\n  );\n};\n\n/**\n * Creates a Yup validation schema based on the provided form configuration.\n *\n * @param config - The form configuration.\n * @param globalValidationMessages - Optional global validation messages.\n * @returns The Yup schema.\n */\nexport const createValidationSchema = (\n  config: FormConfig,\n  globalValidationMessages?: ValidationMessages\n) => {\n  const shape: { [key: string]: yup.AnySchema } = {};\n\n  const validationHandlers: {\n    [key: string]: (\n      fieldSchema: yup.AnySchema,\n      ruleValue: any,\n      validationMessages: any\n    ) => yup.AnySchema;\n  } = {\n    required: handleRequired,\n    minLength: (fieldSchema, ruleValue, validationMessages) =>\n      handleMinLength(\n        fieldSchema as yup.StringSchema,\n        ruleValue,\n        validationMessages\n      ),\n    maxLength: (fieldSchema, ruleValue, validationMessages) =>\n      handleMaxLength(\n        fieldSchema as yup.StringSchema,\n        ruleValue,\n        validationMessages\n      ),\n    min: (fieldSchema, ruleValue, validationMessages) =>\n      handleMin(fieldSchema as yup.NumberSchema, ruleValue, validationMessages),\n    max: (fieldSchema, ruleValue, validationMessages) =>\n      handleMax(fieldSchema as yup.NumberSchema, ruleValue, validationMessages),\n    pattern: (fieldSchema, ruleValue, validationMessages) =>\n      handlePattern(\n        fieldSchema as yup.StringSchema,\n        ruleValue,\n        validationMessages\n      ),\n  };\n\n  for (const fieldId in config) {\n    const fieldConfig = config[fieldId];\n    const { validation, type, validationMessages } = fieldConfig;\n\n    // Merge global and field-level validation messages\n    const mergedValidationMessages = {\n      ...globalValidationMessages,\n      ...validationMessages,\n    };\n\n    if (type === undefined) {\n      console.warn(`Field type is undefined for field: ${fieldId}`);\n    }\n\n    let fieldSchema: yup.AnySchema = getValidationSchema(type!) || yup.mixed();\n\n    if (validation) {\n      const { validate, ...otherValidations } = validation;\n\n      for (const rule in otherValidations) {\n        if (otherValidations.hasOwnProperty(rule)) {\n          const ruleValue = validation[\n            rule as keyof typeof otherValidations\n          ] as any;\n          const handler = validationHandlers[rule];\n          if (handler) {\n            fieldSchema = handler(\n              fieldSchema,\n              ruleValue,\n              mergedValidationMessages // Use merged validation messages\n            );\n          }\n        }\n      }\n\n      if (typeof validate === 'function') {\n        fieldSchema = applyCustomValidation(fieldSchema, validate);\n      }\n    }\n\n    shape[fieldId] = fieldSchema;\n  }\n\n  return yup.object().shape(shape);\n};\n"],"names":[],"sourceRoot":""}