{"version":3,"file":"src_index_ts.f254b38844ce7fa3b491.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAIA;;;;;;;;;AASA;AACA;AAOA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA","sources":["webpack://@matthew.ngo/react-dynamic-form/./src/features/dynamic-form/utils/formUtils.ts"],"sourcesContent":["// src/features/dynamic-form/utils/formUtils.ts\nimport { FieldClassNameConfig, FieldConfig, FormClassNameConfig, FormConfig, FormValues } from '../types';\n\n/**\n * Flattens a nested object into a single-level object.\n *\n * @param obj - The object to flatten.\n * @param parentKey - The parent key (used for recursion).\n * @param result - The resulting flattened object.\n * @returns The flattened object.\n */\nexport const flattenObject = (\n  obj: Record<string, any>,\n  parentKey = '',\n  result: Record<string, any> = {}\n): Record<string, any> => {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = parentKey ? `${parentKey}.${key}` : key;\n      if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {\n        flattenObject(obj[key], newKey, result);\n      } else {\n        result[newKey] = obj[key];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Flattens a nested config object into a single-level object.\n *\n * @param config - The config object to flatten.\n * @param parentKey - The parent key (used for recursion).\n * @param result - The resulting flattened config object.\n * @returns The flattened config object.\n */\nexport const flattenConfig = (\n  config: FormConfig,\n  parentKey = '',\n  result: FormConfig = {}\n): FormConfig => {\n  for (const key in config) {\n    if (Object.prototype.hasOwnProperty.call(config, key)) {\n      const newKey = parentKey ? `${parentKey}.${key}` : key;\n      const fieldConfig = config[key];\n      if (fieldConfig.fields) {\n        flattenConfig(fieldConfig.fields, newKey, result);\n      } else {\n        result[newKey] = fieldConfig;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Debounces a function.\n *\n * @param func - The function to debounce.\n * @param wait - The debounce time in milliseconds.\n * @returns The debounced function.\n */\nexport const debounce = (func: Function, wait: number) => {\n  let timeout: NodeJS.Timeout | null;\n  return function (...args: any[]) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n};\n\n/**\n * Saves data to localStorage.\n *\n * @param key - The key to store the data under.\n * @param data - The data to store.\n */\nexport const saveToLocalStorage = (key: string, data: any) => {\n  localStorage.setItem(key, JSON.stringify(data));\n};\n\n/**\n * Loads data from localStorage.\n *\n * @param key - The key to load the data from.\n * @returns The loaded data, or null if no data is found.\n */\nexport const loadFromLocalStorage = (key: string): any | null => {\n  const data = localStorage.getItem(key);\n  return data ? JSON.parse(data) : null;\n};\n\n\n\n/**\n * Merges multiple classNameConfig objects into a single object, handling nested objects and functions.\n *\n * @param fieldConfig - The field configuration.\n * @param formState - The form state.\n * @param defaultClassNames - The default classNameConfig object.\n * @param formClassNames - The form-level classNameConfig object.\n * @param fieldClassNames - The field-level classNameConfig object.\n * @returns The merged classNameConfig object.\n */\nexport const mergeClassNames = (\n  fieldConfig: FieldConfig,\n  formState: FormState<FormValues>,\n  defaultClassNames: FormClassNameConfig,\n  formClassNames?: FormClassNameConfig,\n  fieldClassNames?: FieldClassNameConfig\n): FormClassNameConfig => {\n  const mergedClassNames: FormClassNameConfig = { ...defaultClassNames };\n\n  const merge = (\n    target: FormClassNameConfig,\n    source?: FormClassNameConfig | FieldClassNameConfig\n  ) => {\n    if (source) {\n      for (const key in source) {\n        const targetValue = target[key];\n        const sourceValue = source[key];\n\n        if (typeof sourceValue === 'string') {\n          target[key] = targetValue\n            ? `${targetValue} ${sourceValue}`\n            : sourceValue;\n        } else if (typeof sourceValue === 'function') {\n          target[key] = sourceValue(fieldConfig, formState);\n        } else if (typeof sourceValue === 'object') {\n          target[key] = targetValue\n            ? merge(\n                targetValue as FormClassNameConfig,\n                sourceValue as FormClassNameConfig\n              )\n            : { ...sourceValue };\n        }\n      }\n    }\n  };\n\n  merge(mergedClassNames, formClassNames);\n  merge(mergedClassNames, fieldClassNames);\n\n  return mergedClassNames;\n};"],"names":[],"sourceRoot":""}